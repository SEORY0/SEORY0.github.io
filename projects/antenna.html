<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dipole Antenna Electric Field Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay Styling matching the reference image vibes */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #e0e0e0;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-left: 3px solid #00ffff;
            border-radius: 4px;
            pointer-events: auto;
            user-select: none;
            backdrop-filter: blur(4px);
            width: 280px;
        }

        h1 {
            font-size: 16px;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #fff;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 5px;
            color: #aaa;
        }

        input[type=range] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 10px #00ffff;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }

        .info-text {
            font-size: 10px;
            color: #666;
            margin-top: 15px;
            line-height: 1.4;
        }
        
        .value-display {
            color: #00ffff;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Dipole E-Field</h1>
        
        <div class="control-group">
            <label>
                Antenna Length (L)
                <span id="length-val" class="value-display">1.0</span>
            </label>
            <input type="range" id="length-slider" min="0.5" max="3.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>
                Propagation Speed
                <span id="speed-val" class="value-display">1.0</span>
            </label>
            <input type="range" id="speed-slider" min="0.0" max="3.0" step="0.1" value="1.0">
        </div>

        <div class="info-text">
            Mouse Left: Rotate Camera<br>
            Mouse Right: Pan<br>
            Scroll: Zoom<br>
            <br>
            Showing Electric Field (E) vector magnitude and direction.
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505); // Very dark gray/black
        scene.fog = new THREE.FogExp2(0x050505, 0.02); // Distance fog

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(15, 10, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. Antenna Geometry ---
        // Center cylinder (The Dipole)
        const antennaGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 16);
        const antennaMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const antenna = new THREE.Mesh(antennaGeo, antennaMat);
        scene.add(antenna);

        // Gap indicator (Center feed point)
        const feedGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const feedMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const feedPoint = new THREE.Mesh(feedGeo, feedMat);
        scene.add(feedPoint);


        // --- 3. Vector Field Setup (InstancedMesh) ---
        // Using InstancedMesh for high performance with thousands of vectors
        const vectorCount = 6000; 
        const dummy = new THREE.Object3D();
        
        // The shape of each vector (a thin elongated box/line)
        const geometry = new THREE.BoxGeometry(0.05, 0.05, 0.6); 
        geometry.translate(0, 0, 0.3); // Pivot at one end
        
        const material = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending // Glow effect
        });

        const fieldMesh = new THREE.InstancedMesh(geometry, material, vectorCount);
        fieldMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(fieldMesh);

        // Generate grid positions for vectors
        const positions = [];
        const spread = 20;
        const density = 18; // Grid resolution

        for (let i = 0; i < vectorCount; i++) {
            // Distribute points in a sphere-ish cloud around the center, avoiding the immediate center
            let r = 1 + Math.random() * spread;
            let theta = Math.random() * Math.PI * 2;
            let phi = Math.acos(2 * Math.random() - 1);

            let x = r * Math.sin(phi) * Math.cos(theta);
            let y = r * Math.sin(phi) * Math.sin(theta); // Switch axis for visual preference if needed, but standard physics: y is up? Let's assume Antenna is Y-axis.
            let z = r * Math.cos(phi);

            // Re-map to Cartesian grid for a cleaner look (optional), but random sphere fills volume better visually
            // Let's stick to random spherical distribution but flatten Y slightly to emphasize the toroid shape of radiation
             x = (Math.random() - 0.5) * spread * 2;
             y = (Math.random() - 0.5) * spread * 1.5;
             z = (Math.random() - 0.5) * spread * 2;

             // Filter out points too close to antenna
             if (Math.sqrt(x*x + z*z) < 0.5) x += 2;

            positions.push(new THREE.Vector3(x, y, z));
        }

        // Color buffer for updating colors individually
        const colors = new Float32Array(vectorCount * 3);

        // --- 4. Simulation State ---
        const state = {
            time: 0,
            antennaLength: 1.0,
            speed: 1.0,
            frequency: 2.0 // Base frequency
        };

        // UI Event Listeners
        const lengthSlider = document.getElementById('length-slider');
        const lengthDisplay = document.getElementById('length-val');
        
        lengthSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            state.antennaLength = val;
            lengthDisplay.innerText = val.toFixed(1);
            
            // Update visual antenna length
            antenna.scale.y = val;
            // Physics: Longer antenna -> Generally lower resonant frequency (Longer wavelength)
            // We simulate this by lowering the frequency slightly in the wave calc
            state.frequency = 2.0 / (val * 0.5 + 0.5); 
        });

        const speedSlider = document.getElementById('speed-slider');
        const speedDisplay = document.getElementById('speed-val');
        speedSlider.addEventListener('input', (e) => {
            state.speed = parseFloat(e.target.value);
            speedDisplay.innerText = state.speed.toFixed(1);
        });


        // --- 5. Animation Loop ---
        const clock = new THREE.Clock();
        const _color = new THREE.Color();
        const upVec = new THREE.Vector3(0, 1, 0); // Antenna axis
        const posVec = new THREE.Vector3();
        const lookTarget = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            state.time += delta * state.speed * 3;

            controls.update();

            // Physics Constants
            const k = state.frequency * 2.0; // Wavenumber
            const omega = state.frequency * 3.0; // Angular frequency

            let idx = 0;
            for (let i = 0; i < vectorCount; i++) {
                posVec.copy(positions[i]);
                
                // r = distance from origin
                const r = posVec.length();
                if (r < 0.1) continue;

                // theta = angle from Y-axis (Antenna axis)
                // dot product: P . Y = |P||Y|cos(theta) => y = r cos(theta) => theta = acos(y/r)
                const cosTheta = posVec.y / r;
                const theta = Math.acos(cosTheta);
                const sinTheta = Math.sin(theta);

                // Dipole Far-field approximation (Simplified for Visuals)
                // Magnitude E ~ (sin(theta) / r) * cos(kr - wt)
                // We dampen 1/r less aggressively (1/r^0.7) to keep distant particles visible
                const wavePhase = k * r - state.time;
                const waveComponent = Math.cos(wavePhase);
                
                // Intensity Calculation
                let intensity = (sinTheta / Math.pow(r, 0.8)) * waveComponent;
                
                // Direction of E-field
                // In far field, E is tangential to the sphere surface (theta-hat direction)
                // Vector construction: Theta-hat is perpendicular to r-hat and in the plane of r and z-axis.
                // Easier method: Tangent to meridian.
                // Step 1: Find vector perpendicular to Position and Y-axis (Phi direction)
                // Step 2: Cross Phi-dir with Position to get Theta-dir
                
                // If point is on Y-axis, simplified handling
                if (Math.abs(posVec.x) < 0.01 && Math.abs(posVec.z) < 0.01) {
                    dummy.position.copy(posVec);
                    dummy.scale.set(0,0,0); // Hide singularity
                } else {
                    // Calculate vector direction (Theta-hat)
                    // T = P x Y (Normal to plane containing P and Y axis)
                    const tVec = new THREE.Vector3().crossVectors(posVec, upVec);
                    // E_dir = T x P (Tangential to sphere, pointing 'south' along meridian)
                    const eDir = new THREE.Vector3().crossVectors(tVec, posVec).normalize();

                    // If wave component is negative, vector flips direction
                    if (intensity < 0) {
                        eDir.negate();
                        intensity = Math.abs(intensity);
                    }

                    // Visualize
                    dummy.position.copy(posVec);
                    
                    // Orient vector
                    lookTarget.copy(dummy.position).add(eDir);
                    dummy.lookAt(lookTarget);

                    // Scale based on intensity (make waves pulse)
                    const scale = Math.min(Math.max(intensity * 5 * state.antennaLength, 0.1), 3.0);
                    dummy.scale.set(1, 1, scale);

                    dummy.updateMatrix();
                    fieldMesh.setMatrixAt(i, dummy.matrix);

                    // Colorize based on intensity (Black -> Cyan -> White)
                    // High intensity = White/Cyan, Low = Dark Blue/Black
                    const bright = Math.min(intensity * 3, 1.0);
                    _color.setHSL(0.5 + (0.1 * (1-bright)), 1.0, bright * 0.5 + 0.1);
                    fieldMesh.setColorAt(i, _color);
                }
            }

            fieldMesh.instanceMatrix.needsUpdate = true;
            if (fieldMesh.instanceColor) fieldMesh.instanceColor.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Memory Cleanup: Dispose Three.js resources on page unload
        window.addEventListener('beforeunload', () => {
            // Dispose all geometries and materials in the scene
            scene.traverse((object) => {
                if (object.geometry) {
                    object.geometry.dispose();
                }
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });

            // Dispose renderer
            renderer.dispose();

            // Remove canvas element
            const canvas = renderer.domElement;
            if (canvas && canvas.parentNode) {
                canvas.parentNode.removeChild(canvas);
            }
        });

    </script>
</body>
</html>